use proc_macro::*;

// It'll be like this
// write_pathway(ident, (ident, "binding"), (ident, "bindi...
// the first ident is the first entity being passed into the pathway
// then, the thing in brackets will be repeated any number of times
// the ident in the brackets represents a field that has declared a query
// the "binding" is a literal, that represents the binding that is going to be created by the query

#[proc_macro]
pub fn write_pathway(input: TokenStream) -> TokenStream {
    let mut stream = input.into_iter();

    // Expect Ident of an entity field for first token
    let pathway_entrance = stream.next();
    let Some(pathway_entrance) = pathway_entrance else {
        return TokenStream::new();
    };
    let Ident(pathway_entrance) = pathway_entrance else {
        return TokenStream::new();
    };


}


// Algorithm
// Autogenerated bindings
// write_pathway(ident, ident, ident...

// loop
// expect ident
// create query statement from ident and previously stored entity field
// store entity field
// expect end or comma



// issues
// mutablity, shadowing, entity field, query structure

// Mutablity, it could be possible that it coudl be inferred from the fact that the query statement will or wont be mutable
// Do we have that information though? I will test this in the proto...
// I should test to see how type IDs work too, if I have that information, then there're more possibilities.

// Shadowing? Or is this more like that it has to be scoped?
// Yeah, it has to be one of these I think let = {...}
// And then that also means, that there has to be a signifier for what should and shouldn't be shadowed
// not shadowed, but you know what I mean

// Okay, the bindings do this implicitlly, same with the mutablitiy issue

// entity field, yeah, so this comes back to query structure, hmm...
// the macro will have to somehow know what field from the returned tuple is the entity
// fuck
// Okay? Basically, the query tuple has to be entered into the macro no? And then? 
// Yeah this is the big thing, the system actually has to be prepared for pathways that branch. How does it do that? 
// Well recursion or something right?
// Okay? SO this means, that nesting within the decleration has to exist basically right? I think so...

// ident (group/ident, "")

// But wait though?
// Does that mean a straight pathway is defined as a bunch of nesting? That sounds terrible.
// Okay...

// ident [query, optional binding, ...]
// and then if you have a query that branches
// ident [branching query, optional binding, ([query, optional binding], [query, optional binding])]
// oh jesus...
// Yeah best to think of it at the simple scale but have it work for when people build monstrosities like that, but to not think of that while making it

// Okay, holdup though
// This is really similar to usage things
// ident::(ident, query, optional binding)::
// and query can be expanded? Yeah, so the query only needs to declare the entity being gotten from the query
// hmm, it doesn't actually need to exist, if I just format my queries so that the entity stuff is always at the beginning of them
// I think that'll confuse people though
// hmm... 

// the bindings are the same as the query thing
// but the query thing implies that that it wont be exposed
// hmm... the entities from the query should also be bindable 

// Okay, I have an idea
// this basically 1varname
// so the number defines the tuple location of the ting
// hmm...

// entrance_entity::{query1, (optional bindings..., entity_binding1::{... })}
// plus the other stuff, that'd work
// Though, this means that for every step, there is more and more nesting
// Hmm... this is why we seperate the group for entity and optional bindings

// entrance_entity::{query1, (optional bindings,... ), entity_binding1}::
// hmm

// entrance_entity::query1::(optional bindings, ...)::entity_binding::query2::...
// Yeah that's it
// entrance_entity::{
//    (query1::(optional bindings, ...)::entity_binding::query3::... ),
//    (query2::(optional bindings, ...)::entity_binding::query4::... )
// }
// So every entity binding can expand like that

// Plus the sauce from bindings mutability and tuple field location dennoters, that should be it
// Now I gotta make it...

// I'll also do those tests though, test to see if mutability and typeID can be gotten from an Ident
// I think it's fine if they can't though, typeID will be useless pretty sure anyways, but I will check